\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}

\author{Nima Seyedtalebi}
\title{A Heuristic Approach for Efficient Edge Computing Pipeline Placement}

\newcommand{\forallv}[1]{\ensuremath{\forall #1 \in V}}

\newcommand{\foralle}[2]{\ensuremath{\forall (#1,#2) \in E }}

\begin{document}
	\maketitle
	\begin{abstract}
		The \textit{edge computing pipeline placement problem} (EPP) is the following: given an undirected graph $G=(V,E)$ with $V$ nodes and $E$ edges, edge weights $w_{ij} \space \foralle{i}{j}$, compute capacities $c_{j} \space \forallv{j}$, and a pipeline specification $P = (n,C_{s},I_{s},v_{out})$, where  $n$ is the number of pipline stages, $C_{s}$ the required capacities for each stage, $I_{s}$ the locations of the input data for each stage, and $v_{out}$. The goal is to find an assignment $A$ that minimizes the total weight of the tree that spans the input nodes, output node, and assigned pipe stages. In this paper, we shall propose a greedy approximation algorithm for EPP that places each stage of the pipeline separately, present two alternative implementations, and analyze the performance of these implementations on synthetic networks.
		%$C_{r} = \{ C_{r}|r \in \mathbb{N} \wedge 0 \le r \le n\}$
	\end{abstract}
	
	\section{Introduction}
	The number of Internet protocol (IP) connected devices is growing rapidly. According to the Cisco Visual Networking Index, by 2022 the number of connected devices will be more than three times the global population. 71 percent of these devices will be wireless or mobile by that time, and as a whole they will produce 4.8 Zettabytes of data (compared to the 1.5 ZB in 2017).\cite{ciscoVNI} Compute capacity has grown to meet rising demands but network performance has not increased as quickly, leading to bottlenecks in the network. Edge computing is a computational paradigm developed in response to this problem \cite{edgeEmerge},\cite{edgePromise}. The key idea of edge computing is that we can reduce the impact of the networking bottleneck by moving computation closer (in networking terms) to the input data.
	
	The Cresco distributed edge computing framework developed by Bumgardner et al.\cite{bumgardner2016cresco} addresses this problem. Part of Cresco's design is based on principles from agent-based systems and the actor programming model. Each node in a Cresco deployment is an intelligent agent that can act autonomously. Agents communicate by exchanging text-based messages and form the basis for Cresco's hierarchical control structure. Each agent may load plugins, or user-defined modules that run locally on the agent. These plugins are what perform the computations and represent the part of the framework supplied by users. They may be loaded and unloaded freely while the framework is running (i.e. they are "hot-swappable").
	
	Cresco deployments are divided into regions and include an implicit "global" region. An agent in each region is selected to be a regional controller which is responsible for all of the agents in the region. Regional controllers track the state of  agents in the region and route messages to or from other regions. All regional controllers report to a global controller. This global controller performs all of the regional controller duties and acts as a regional controller for the implied global region. It also decides how to provision framework resources based on performance data, topology data, and user-specified constraints.
	
	In general, the topology of a Cresco deployment is dynamic. Although agents may be statically assigned to regional or global controller roles, each agent initiates a discovery process upon startup that allow agents to become regional or global controllers if none are present. Regional and global membership are determined by use of a shared secret key. If an active regional controller becomes unreachable, any agent in the region may take its place as the regional controller. The same is true for the global controller. Note that this happens automatically without any operator intervention. The regional and global controllers continuously assess the performance and health of the deployment and can automatically relocate computations to optimize performance by using the plugin mechanism described above.
	
    Users of the framework implement their applications as a collection of Cresco plugins that act as microservices. This dynamic, microservice-based approach is similar to the OSGi model\footnote{The most recent verison of Cresco is built using the OSGi framework} and is informed by trends toward inversion-of-control in large-scale software design \cite{osgi},\cite{spring},\cite{kubernetes}. 
	
	
	
	
	\bibliographystyle{plain}
	\bibliography{report}
\end{document}

